{"version":3,"sources":["../../../src/facilitator/index.ts","../../../src/types/shared/evm/config.ts","../../../src/types/shared/evm/eip3009.ts","../../../src/types/shared/evm/erc20PermitABI.ts","../../../src/types/shared/evm/wallet.ts","../../../src/schemes/exact/evm/sign.ts","../../../src/shared/base64.ts","../../../src/types/shared/money.ts","../../../src/types/shared/network.ts","../../../src/shared/svm/wallet.ts","../../../src/shared/svm/rpc.ts","../../../src/types/shared/svm/regex.ts","../../../src/shared/network.ts","../../../src/types/verify/x402Specs.ts","../../../src/types/verify/facilitator.ts","../../../src/shared/evm/usdc.ts","../../../src/shared/evm/erc20.ts","../../../src/shared/svm/transaction.ts","../../../src/schemes/exact/evm/facilitator.ts","../../../src/schemes/exact/svm/facilitator/settle.ts","../../../src/schemes/exact/svm/facilitator/verify.ts","../../../src/schemes/exact/svm/client.ts","../../../src/schemes/exact/index.ts","../../../src/facilitator/facilitator.ts"],"sourcesContent":["export * from \"./facilitator\";\n","import { Address } from \"viem\";\nimport { Address as SolanaAddress } from \"@solana/kit\";\n\nexport const config: Record<string, ChainConfig> = {\n  \"84532\": {\n    usdcAddress: \"0x036CbD53842c5426634e7929541eC2318f3dCF7e\",\n    usdcName: \"USDC\",\n  },\n  \"8453\": {\n    usdcAddress: \"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913\",\n    usdcName: \"USD Coin\",\n  },\n  \"43113\": {\n    usdcAddress: \"0x5425890298aed601595a70AB815c96711a31Bc65\",\n    usdcName: \"USD Coin\",\n  },\n  \"43114\": {\n    usdcAddress: \"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E\",\n    usdcName: \"USD Coin\",\n  },\n  \"4689\": {\n    usdcAddress: \"0xcdf79194c6c285077a58da47641d4dbe51f63542\",\n    usdcName: \"Bridged USDC\",\n  },\n  // solana devnet\n  \"103\": {\n    usdcAddress: \"4zMMC9srt5Ri5X14GAgXhaHii3GnPAEERYPJgZJDncDU\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  // solana mainnet\n  \"101\": {\n    usdcAddress: \"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\" as SolanaAddress,\n    usdcName: \"USDC\",\n  },\n  \"1328\": {\n    usdcAddress: \"0x4fcf1784b31630811181f670aea7a7bef803eaed\",\n    usdcName: \"USDC\",\n  },\n  \"1329\": {\n    usdcAddress: \"0xe15fc38f6d8c56af07bbcbe3baf5708a2bf42392\",\n    usdcName: \"USDC\",\n  },\n};\n\nexport type ChainConfig = {\n  usdcAddress: Address | SolanaAddress;\n  usdcName: string;\n};\n","export const authorizationTypes = {\n  TransferWithAuthorization: [\n    { name: \"from\", type: \"address\" },\n    { name: \"to\", type: \"address\" },\n    { name: \"value\", type: \"uint256\" },\n    { name: \"validAfter\", type: \"uint256\" },\n    { name: \"validBefore\", type: \"uint256\" },\n    { name: \"nonce\", type: \"bytes32\" },\n  ],\n};\n\nexport const authorizationPrimaryType = \"TransferWithAuthorization\";\n","export const usdcABI = [\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"owner\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"spender\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Approval\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationCanceled\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"authorizer\",\n        type: \"address\",\n      },\n      {\n        indexed: true,\n        internalType: \"bytes32\",\n        name: \"nonce\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"AuthorizationUsed\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"Blacklisted\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newBlacklister\",\n        type: \"address\",\n      },\n    ],\n    name: \"BlacklisterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"burner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Burn\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newMasterMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MasterMinterChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"amount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Mint\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"minter\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"minterAllowedAmount\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"MinterConfigured\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"oldMinter\",\n        type: \"address\",\n      },\n    ],\n    name: \"MinterRemoved\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"previousOwner\",\n        type: \"address\",\n      },\n      {\n        indexed: false,\n        internalType: \"address\",\n        name: \"newOwner\",\n        type: \"address\",\n      },\n    ],\n    name: \"OwnershipTransferred\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Pause\", type: \"event\" },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newAddress\",\n        type: \"address\",\n      },\n    ],\n    name: \"PauserChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"newRescuer\",\n        type: \"address\",\n      },\n    ],\n    name: \"RescuerChanged\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      { indexed: true, internalType: \"address\", name: \"from\", type: \"address\" },\n      { indexed: true, internalType: \"address\", name: \"to\", type: \"address\" },\n      {\n        indexed: false,\n        internalType: \"uint256\",\n        name: \"value\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"Transfer\",\n    type: \"event\",\n  },\n  {\n    anonymous: false,\n    inputs: [\n      {\n        indexed: true,\n        internalType: \"address\",\n        name: \"_account\",\n        type: \"address\",\n      },\n    ],\n    name: \"UnBlacklisted\",\n    type: \"event\",\n  },\n  { anonymous: false, inputs: [], name: \"Unpause\", type: \"event\" },\n  {\n    inputs: [],\n    name: \"CANCEL_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"DOMAIN_SEPARATOR\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"PERMIT_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"RECEIVE_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"TRANSFER_WITH_AUTHORIZATION_TYPEHASH\",\n    outputs: [{ internalType: \"bytes32\", name: \"\", type: \"bytes32\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n    ],\n    name: \"allowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"approve\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n    ],\n    name: \"authorizationState\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"balanceOf\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"blacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"blacklister\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"uint256\", name: \"_amount\", type: \"uint256\" }],\n    name: \"burn\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"authorizer\", type: \"address\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"cancelAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"minter\", type: \"address\" },\n      { internalType: \"uint256\", name: \"minterAllowedAmount\", type: \"uint256\" },\n    ],\n    name: \"configureMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"currency\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"decimals\",\n    outputs: [{ internalType: \"uint8\", name: \"\", type: \"uint8\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"decrement\", type: \"uint256\" },\n    ],\n    name: \"decreaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"increment\", type: \"uint256\" },\n    ],\n    name: \"increaseAllowance\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"string\", name: \"tokenName\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenSymbol\", type: \"string\" },\n      { internalType: \"string\", name: \"tokenCurrency\", type: \"string\" },\n      { internalType: \"uint8\", name: \"tokenDecimals\", type: \"uint8\" },\n      { internalType: \"address\", name: \"newMasterMinter\", type: \"address\" },\n      { internalType: \"address\", name: \"newPauser\", type: \"address\" },\n      { internalType: \"address\", name: \"newBlacklister\", type: \"address\" },\n      { internalType: \"address\", name: \"newOwner\", type: \"address\" },\n    ],\n    name: \"initialize\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"string\", name: \"newName\", type: \"string\" }],\n    name: \"initializeV2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"lostAndFound\", type: \"address\" }],\n    name: \"initializeV2_1\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"address[]\",\n        name: \"accountsToBlacklist\",\n        type: \"address[]\",\n      },\n      { internalType: \"string\", name: \"newSymbol\", type: \"string\" },\n    ],\n    name: \"initializeV2_2\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"isBlacklisted\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"account\", type: \"address\" }],\n    name: \"isMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"masterMinter\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"_to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"_amount\", type: \"uint256\" },\n    ],\n    name: \"mint\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"minterAllowance\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"name\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"owner\", type: \"address\" }],\n    name: \"nonces\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"owner\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"paused\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"pauser\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"owner\", type: \"address\" },\n      { internalType: \"address\", name: \"spender\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"deadline\", type: \"uint256\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"permit\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"receiveWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"minter\", type: \"address\" }],\n    name: \"removeMinter\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"contract IERC20\",\n        name: \"tokenContract\",\n        type: \"address\",\n      },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"amount\", type: \"uint256\" },\n    ],\n    name: \"rescueERC20\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"rescuer\",\n    outputs: [{ internalType: \"address\", name: \"\", type: \"address\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"symbol\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"totalSupply\",\n    outputs: [{ internalType: \"uint256\", name: \"\", type: \"uint256\" }],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transfer\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n    ],\n    name: \"transferFrom\",\n    outputs: [{ internalType: \"bool\", name: \"\", type: \"bool\" }],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newOwner\", type: \"address\" }],\n    name: \"transferOwnership\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"bytes\", name: \"signature\", type: \"bytes\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      { internalType: \"address\", name: \"from\", type: \"address\" },\n      { internalType: \"address\", name: \"to\", type: \"address\" },\n      { internalType: \"uint256\", name: \"value\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validAfter\", type: \"uint256\" },\n      { internalType: \"uint256\", name: \"validBefore\", type: \"uint256\" },\n      { internalType: \"bytes32\", name: \"nonce\", type: \"bytes32\" },\n      { internalType: \"uint8\", name: \"v\", type: \"uint8\" },\n      { internalType: \"bytes32\", name: \"r\", type: \"bytes32\" },\n      { internalType: \"bytes32\", name: \"s\", type: \"bytes32\" },\n    ],\n    name: \"transferWithAuthorization\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_account\", type: \"address\" }],\n    name: \"unBlacklist\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"unpause\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newBlacklister\", type: \"address\" }],\n    name: \"updateBlacklister\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newMasterMinter\", type: \"address\" }],\n    name: \"updateMasterMinter\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"_newPauser\", type: \"address\" }],\n    name: \"updatePauser\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [{ internalType: \"address\", name: \"newRescuer\", type: \"address\" }],\n    name: \"updateRescuer\",\n    outputs: [],\n    stateMutability: \"nonpayable\",\n    type: \"function\",\n  },\n  {\n    inputs: [],\n    name: \"version\",\n    outputs: [{ internalType: \"string\", name: \"\", type: \"string\" }],\n    stateMutability: \"pure\",\n    type: \"function\",\n  },\n] as const;\n","import { createPublicClient, createWalletClient, http, publicActions } from \"viem\";\nimport type {\n  Chain,\n  Transport,\n  Client,\n  Account,\n  RpcSchema,\n  PublicActions,\n  WalletActions,\n  PublicClient,\n  LocalAccount,\n} from \"viem\";\nimport { baseSepolia, avalancheFuji, base, sei, seiTestnet } from \"viem/chains\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Hex } from \"viem\";\n\n// Create a public client for reading data\nexport type SignerWallet<\n  chain extends Chain = Chain,\n  transport extends Transport = Transport,\n  account extends Account = Account,\n> = Client<\n  transport,\n  chain,\n  account,\n  RpcSchema,\n  PublicActions<transport, chain, account> & WalletActions<chain, account>\n>;\n\nexport type ConnectedClient<\n  transport extends Transport = Transport,\n  chain extends Chain | undefined = Chain,\n  account extends Account | undefined = undefined,\n> = PublicClient<transport, chain, account>;\n\nexport type EvmSigner = SignerWallet<Chain, Transport, Account> | LocalAccount;\n\n/**\n * Creates a public client configured for the specified network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createConnectedClient(\n  network: string,\n): ConnectedClient<Transport, Chain, undefined> {\n  const chain = getChainFromNetwork(network);\n  return createPublicClient({\n    chain,\n    transport: http(),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a public client configured for the Base Sepolia testnet\n *\n * @deprecated Use `createConnectedClient(\"base-sepolia\")` instead\n * @returns A public client instance connected to Base Sepolia\n */\nexport function createClientSepolia(): ConnectedClient<Transport, typeof baseSepolia, undefined> {\n  return createConnectedClient(\"base-sepolia\") as ConnectedClient<\n    Transport,\n    typeof baseSepolia,\n    undefined\n  >;\n}\n\n/**\n * Creates a public client configured for the Avalanche Fuji testnet\n *\n * @deprecated Use `createConnectedClient(\"avalanche-fuji\")` instead\n * @returns A public client instance connected to Avalanche Fuji\n */\nexport function createClientAvalancheFuji(): ConnectedClient<\n  Transport,\n  typeof avalancheFuji,\n  undefined\n> {\n  return createConnectedClient(\"avalanche-fuji\") as ConnectedClient<\n    Transport,\n    typeof avalancheFuji,\n    undefined\n  >;\n}\n\n/**\n * Creates a wallet client configured for the specified chain with a private key\n *\n * @param network - The network to connect to\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to the specified chain with the provided private key\n */\nexport function createSigner(network: string, privateKey: Hex): SignerWallet<Chain> {\n  const chain = getChainFromNetwork(network);\n  return createWalletClient({\n    chain,\n    transport: http(),\n    account: privateKeyToAccount(privateKey),\n  }).extend(publicActions);\n}\n\n/**\n * Creates a wallet client configured for the Base Sepolia testnet with a private key\n *\n * @deprecated Use `createSigner(\"base-sepolia\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Base Sepolia with the provided private key\n */\nexport function createSignerSepolia(privateKey: Hex): SignerWallet<typeof baseSepolia> {\n  return createSigner(\"base-sepolia\", privateKey) as SignerWallet<typeof baseSepolia>;\n}\n\n/**\n * Creates a wallet client configured for the Avalanche Fuji testnet with a private key\n *\n * @deprecated Use `createSigner(\"avalanche-fuji\", privateKey)` instead\n * @param privateKey - The private key to use for signing transactions\n * @returns A wallet client instance connected to Avalanche Fuji with the provided private key\n */\nexport function createSignerAvalancheFuji(privateKey: Hex): SignerWallet<typeof avalancheFuji> {\n  return createSigner(\"avalanche-fuji\", privateKey) as SignerWallet<typeof avalancheFuji>;\n}\n\n/**\n * Checks if a wallet is a signer wallet\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is a signer wallet, false otherwise\n */\nexport function isSignerWallet<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(\n  wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount,\n): wallet is SignerWallet<TChain, TTransport, TAccount> {\n  return (\n    typeof wallet === \"object\" && wallet !== null && \"chain\" in wallet && \"transport\" in wallet\n  );\n}\n\n/**\n * Checks if a wallet is an account\n *\n * @param wallet - The wallet to check\n * @returns True if the wallet is an account, false otherwise\n */\nexport function isAccount<\n  TChain extends Chain = Chain,\n  TTransport extends Transport = Transport,\n  TAccount extends Account = Account,\n>(wallet: SignerWallet<TChain, TTransport, TAccount> | LocalAccount): wallet is LocalAccount {\n  const w = wallet as LocalAccount;\n  return (\n    typeof wallet === \"object\" &&\n    wallet !== null &&\n    typeof w.address === \"string\" &&\n    typeof w.type === \"string\" &&\n    // Check for essential signing capabilities\n    typeof w.sign === \"function\" &&\n    typeof w.signMessage === \"function\" &&\n    typeof w.signTypedData === \"function\" &&\n    // Check for transaction signing (required by LocalAccount)\n    typeof w.signTransaction === \"function\"\n  );\n}\n\n/**\n * Maps network strings to Chain objects\n *\n * @param network - The network string to convert to a Chain object\n * @returns The corresponding Chain object\n */\nfunction getChainFromNetwork(network: string | undefined): Chain {\n  if (!network) {\n    throw new Error(\"NETWORK environment variable is not set\");\n  }\n\n  switch (network) {\n    case \"base\":\n      return base;\n    case \"base-sepolia\":\n      return baseSepolia;\n    case \"avalanche-fuji\":\n      return avalancheFuji;\n    case \"sei\":\n      return sei;\n    case \"sei-testnet\":\n      return seiTestnet;\n    default:\n      throw new Error(`Unsupported network: ${network}`);\n  }\n}\n","import { Chain, getAddress, Hex, LocalAccount, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | LocalAccount,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset),\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","export const Base64EncodedRegex = /^[A-Za-z0-9+/]*={0,2}$/;\n\n/**\n * Encodes a string to base64 format\n *\n * @param data - The string to be encoded to base64\n * @returns The base64 encoded string\n */\nexport function safeBase64Encode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.btoa === \"function\") {\n    return globalThis.btoa(data);\n  }\n  return Buffer.from(data).toString(\"base64\");\n}\n\n/**\n * Decodes a base64 string back to its original format\n *\n * @param data - The base64 encoded string to be decoded\n * @returns The decoded string in UTF-8 format\n */\nexport function safeBase64Decode(data: string): string {\n  if (typeof globalThis !== \"undefined\" && typeof globalThis.atob === \"function\") {\n    return globalThis.atob(data);\n  }\n  return Buffer.from(data, \"base64\").toString(\"utf-8\");\n}\n","import { z } from \"zod\";\n\nexport const moneySchema = z\n  .union([z.string().transform(x => x.replace(/[^0-9.-]+/g, \"\")), z.number()])\n  .pipe(z.coerce.number().min(0.0001).max(999999999));\n\nexport type Money = z.input<typeof moneySchema>;\n","import { z } from \"zod\";\n\nexport const NetworkSchema = z.enum([\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"solana-devnet\",\n  \"solana\",\n  \"sei\",\n  \"sei-testnet\",\n]);\nexport type Network = z.infer<typeof NetworkSchema>;\n\n// evm\nexport const SupportedEVMNetworks: Network[] = [\n  \"base-sepolia\",\n  \"base\",\n  \"avalanche-fuji\",\n  \"avalanche\",\n  \"iotex\",\n  \"sei\",\n  \"sei-testnet\",\n];\nexport const EvmNetworkToChainId = new Map<Network, number>([\n  [\"base-sepolia\", 84532],\n  [\"base\", 8453],\n  [\"avalanche-fuji\", 43113],\n  [\"avalanche\", 43114],\n  [\"iotex\", 4689],\n  [\"sei\", 1329],\n  [\"sei-testnet\", 1328],\n]);\n\n// svm\nexport const SupportedSVMNetworks: Network[] = [\"solana-devnet\", \"solana\"];\nexport const SvmNetworkToChainId = new Map<Network, number>([\n  [\"solana-devnet\", 103],\n  [\"solana\", 101],\n]);\n\nexport const ChainIdToNetwork = Object.fromEntries(\n  [...SupportedEVMNetworks, ...SupportedSVMNetworks].map(network => [\n    EvmNetworkToChainId.get(network),\n    network,\n  ]),\n) as Record<number, Network>;\n","import {\n  createKeyPairSignerFromBytes,\n  type KeyPairSigner,\n  createKeyPairSignerFromPrivateKeyBytes,\n  type RpcDevnet,\n  type SolanaRpcApiDevnet,\n  type RpcMainnet,\n  type SolanaRpcApiMainnet,\n  isKeyPairSigner,\n} from \"@solana/kit\";\nimport { base58 } from \"@scure/base\";\nimport { getRpcClient } from \"./rpc\";\nimport { Network, SupportedSVMNetworks } from \"../../types/shared\";\nexport type { KeyPairSigner } from \"@solana/kit\";\n\nexport type SvmConnectedClient = RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>;\nexport type SvmSigner = KeyPairSigner;\n\n/**\n * Creates a public client configured for the specified SVM network\n *\n * @param network - The network to connect to\n * @returns A public client instance connected to the specified chain\n */\nexport function createSvmConnectedClient(network: string): SvmConnectedClient {\n  if (!SupportedSVMNetworks.find(n => n === network)) {\n    throw new Error(`Unsupported SVM network: ${network}`);\n  }\n  return getRpcClient(network as Network);\n}\n\n/**\n * Creates a Solana signer from a private key.\n *\n * @param privateKey - The base58 encoded private key to create a signer from.\n * @returns A Solana signer.\n */\nexport async function createSignerFromBase58(privateKey: string): Promise<KeyPairSigner> {\n  // decode the base58 encoded private key\n  const bytes = base58.decode(privateKey);\n\n  // generate a keypair signer from the bytes based on the byte-length\n  // 64 bytes represents concatenated private + public key\n  if (bytes.length === 64) {\n    return await createKeyPairSignerFromBytes(bytes);\n  }\n  // 32 bytes represents only the private key\n  if (bytes.length === 32) {\n    return await createKeyPairSignerFromPrivateKeyBytes(bytes);\n  }\n  throw new Error(`Unexpected key length: ${bytes.length}. Expected 32 or 64 bytes.`);\n}\n\n/**\n * Checks if the given wallet is a solana KeyPairSigner wallet.\n *\n * @param wallet - The object wallet to check.\n * @returns True if the wallet is a solana KeyPairSigner wallet, false otherwise.\n */\nexport function isSignerWallet(wallet: SvmSigner): wallet is SvmSigner {\n  return isKeyPairSigner(wallet);\n}\n","import {\n  createSolanaRpc,\n  devnet,\n  mainnet,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcMainnet,\n  createSolanaRpcSubscriptions,\n  RpcSubscriptionsFromTransport,\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl,\n  ClusterUrl,\n} from \"@solana/kit\";\nimport { Network } from \"../../types/shared\";\n\n/**\n * Creates a Solana RPC client for the devnet network.\n *\n * @param url - Optional URL of the devnet network.\n * @returns A Solana RPC client.\n */\nexport function createDevnetRpcClient(url?: string): RpcDevnet<SolanaRpcApiDevnet> {\n  return createSolanaRpc(\n    url ? devnet(url) : devnet(\"https://api.devnet.solana.com\"),\n  ) as RpcDevnet<SolanaRpcApiDevnet>;\n}\n\n/**\n * Creates a Solana RPC client for the mainnet network.\n *\n * @param url - Optional URL of the mainnet network.\n * @returns A Solana RPC client.\n */\nexport function createMainnetRpcClient(url?: string): RpcMainnet<SolanaRpcApiMainnet> {\n  return createSolanaRpc(\n    url ? mainnet(url) : mainnet(\"https://api.mainnet-beta.solana.com\"),\n  ) as RpcMainnet<SolanaRpcApiMainnet>;\n}\n\n/**\n * Gets the RPC client for the given network.\n *\n * @param network - The network to get the RPC client for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC client for the given network\n */\nexport function getRpcClient(\n  network: Network,\n  url?: string,\n): RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createDevnetRpcClient(url);\n  } else if (network === \"solana\") {\n    return createMainnetRpcClient(url);\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n\n/**\n * Gets the RPC subscriptions for the given network.\n *\n * @param network - The network to get the RPC subscriptions for\n * @param url - Optional URL of the network. If not provided, the default URL will be used.\n * @returns The RPC subscriptions for the given network\n */\nexport function getRpcSubscriptions(\n  network: Network,\n  url?: string,\n): RpcSubscriptionsFromTransport<\n  SolanaRpcSubscriptionsApi,\n  RpcSubscriptionsTransportFromClusterUrl<ClusterUrl>\n> {\n  // TODO: should the networks be replaced with enum references?\n  if (network === \"solana-devnet\") {\n    return createSolanaRpcSubscriptions(devnet(url ?? \"wss://api.devnet.solana.com\"));\n  } else if (network === \"solana\") {\n    return createSolanaRpcSubscriptions(mainnet(url ?? \"wss://api.mainnet-beta.solana.com\"));\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n}\n","export const SvmAddressRegex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;\n","import { EvmNetworkToChainId, Network, SvmNetworkToChainId } from \"../types/shared\";\n\n/**\n * Converts a network name to its corresponding chain ID\n *\n * @param network - The network name to convert to a chain ID\n * @returns The chain ID for the specified network\n * @throws Error if the network is not supported\n */\nexport function getNetworkId(network: Network): number {\n  if (EvmNetworkToChainId.has(network)) {\n    return EvmNetworkToChainId.get(network)!;\n  }\n  if (SvmNetworkToChainId.has(network)) {\n    return SvmNetworkToChainId.get(network)!;\n  }\n  throw new Error(`Unsupported network: ${network}`);\n}\n","import { z } from \"zod\";\nimport { NetworkSchema } from \"../shared\";\nimport { SvmAddressRegex } from \"../shared/svm\";\nimport { Base64EncodedRegex } from \"../../shared/base64\";\n\n// Constants\nconst EvmMaxAtomicUnits = 18;\nconst EvmAddressRegex = /^0x[0-9a-fA-F]{40}$/;\nconst MixedAddressRegex = /^0x[a-fA-F0-9]{40}|[A-Za-z0-9][A-Za-z0-9-]{0,34}[A-Za-z0-9]$/;\nconst HexEncoded64ByteRegex = /^0x[0-9a-fA-F]{64}$/;\nconst EvmSignatureRegex = /^0x[0-9a-fA-F]+$/; // Flexible hex signature validation\n// Enums\nexport const schemes = [\"exact\"] as const;\nexport const x402Versions = [1] as const;\nexport const ErrorReasons = [\n  \"insufficient_funds\",\n  \"invalid_exact_evm_payload_authorization_valid_after\",\n  \"invalid_exact_evm_payload_authorization_valid_before\",\n  \"invalid_exact_evm_payload_authorization_value\",\n  \"invalid_exact_evm_payload_signature\",\n  \"invalid_exact_evm_payload_recipient_mismatch\",\n  \"invalid_exact_svm_payload_transaction\",\n  \"invalid_exact_svm_payload_transaction_amount_mismatch\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee\",\n  \"invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset\",\n  \"invalid_exact_svm_payload_transaction_instructions\",\n  \"invalid_exact_svm_payload_transaction_instructions_length\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction\",\n  \"invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked\",\n  \"invalid_exact_svm_payload_transaction_not_a_transfer_instruction\",\n  \"invalid_exact_svm_payload_transaction_cannot_derive_receiver_ata\",\n  \"invalid_exact_svm_payload_transaction_receiver_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_sender_ata_not_found\",\n  \"invalid_exact_svm_payload_transaction_simulation_failed\",\n  \"invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata\",\n  \"invalid_network\",\n  \"invalid_payload\",\n  \"invalid_payment_requirements\",\n  \"invalid_scheme\",\n  \"invalid_payment\",\n  \"payment_expired\",\n  \"unsupported_scheme\",\n  \"invalid_x402_version\",\n  \"invalid_transaction_state\",\n  \"invalid_x402_version\",\n  \"settle_exact_svm_block_height_exceeded\",\n  \"settle_exact_svm_transaction_confirmation_timed_out\",\n  \"unsupported_scheme\",\n  \"unexpected_settle_error\",\n  \"unexpected_verify_error\",\n] as const;\n\n// Refiners\nconst isInteger: (value: string) => boolean = value =>\n  Number.isInteger(Number(value)) && Number(value) >= 0;\nconst hasMaxLength = (maxLength: number) => (value: string) => value.length <= maxLength;\n\n// x402PaymentRequirements\nconst EvmOrSvmAddress = z.string().regex(EvmAddressRegex).or(z.string().regex(SvmAddressRegex));\nconst mixedAddressOrSvmAddress = z\n  .string()\n  .regex(MixedAddressRegex)\n  .or(z.string().regex(SvmAddressRegex));\nexport const PaymentRequirementsSchema = z.object({\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  maxAmountRequired: z.string().refine(isInteger),\n  resource: z.string().url(),\n  description: z.string(),\n  mimeType: z.string(),\n  outputSchema: z.record(z.any()).optional(),\n  payTo: EvmOrSvmAddress,\n  maxTimeoutSeconds: z.number().int(),\n  asset: mixedAddressOrSvmAddress,\n  extra: z.record(z.any()).optional(),\n});\nexport type PaymentRequirements = z.infer<typeof PaymentRequirementsSchema>;\n\n// x402ExactEvmPayload\nexport const ExactEvmPayloadAuthorizationSchema = z.object({\n  from: z.string().regex(EvmAddressRegex),\n  to: z.string().regex(EvmAddressRegex),\n  value: z.string().refine(isInteger).refine(hasMaxLength(EvmMaxAtomicUnits)),\n  validAfter: z.string().refine(isInteger),\n  validBefore: z.string().refine(isInteger),\n  nonce: z.string().regex(HexEncoded64ByteRegex),\n});\nexport type ExactEvmPayloadAuthorization = z.infer<typeof ExactEvmPayloadAuthorizationSchema>;\n\nexport const ExactEvmPayloadSchema = z.object({\n  signature: z.string().regex(EvmSignatureRegex),\n  authorization: ExactEvmPayloadAuthorizationSchema,\n});\nexport type ExactEvmPayload = z.infer<typeof ExactEvmPayloadSchema>;\n\n// x402ExactSvmPayload\nexport const ExactSvmPayloadSchema = z.object({\n  transaction: z.string().regex(Base64EncodedRegex),\n});\nexport type ExactSvmPayload = z.infer<typeof ExactSvmPayloadSchema>;\n\n// x402PaymentPayload\nexport const PaymentPayloadSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  payload: z.union([ExactEvmPayloadSchema, ExactSvmPayloadSchema]),\n});\nexport type PaymentPayload = z.infer<typeof PaymentPayloadSchema>;\nexport type UnsignedPaymentPayload = Omit<PaymentPayload, \"payload\"> & {\n  payload: Omit<ExactEvmPayload, \"signature\"> & { signature: undefined };\n};\n\n// x402 Resource Server Response\nexport const x402ResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  error: z.enum(ErrorReasons).optional(),\n  accepts: z.array(PaymentRequirementsSchema).optional(),\n  payer: z.string().regex(MixedAddressRegex).optional(),\n});\nexport type x402Response = z.infer<typeof x402ResponseSchema>;\n\n// x402RequestStructure\nconst HTTPVerbsSchema = z.enum([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\", \"HEAD\"]);\nexport type HTTPVerbs = z.infer<typeof HTTPVerbsSchema>;\n\nexport const HTTPRequestStructureSchema = z.object({\n  type: z.literal(\"http\"),\n  method: HTTPVerbsSchema,\n  queryParams: z.record(z.string(), z.string()).optional(),\n  bodyType: z.enum([\"json\", \"form-data\", \"multipart-form-data\", \"text\", \"binary\"]).optional(),\n  bodyFields: z.record(z.string(), z.any()).optional(),\n  headerFields: z.record(z.string(), z.any()).optional(),\n});\n\n// export const MCPRequestStructureSchema = z.object({\n//   type: z.literal(\"mcp\"),\n//   sessionIsPayed: z.boolean(),\n//   payedAction: z.object({\n//     kind: z.enum([\"prompts\", \"resources\", \"tools\"]),\n//     name: z.string(),\n//   }).optional(),\n// });\n\n// export const OpenAPIRequestStructureSchema = z.object({\n//   type: z.literal(\"openapi\"),\n//   openApiUrl: z.string().url(),\n//   path: z.string(),\n// });\n\nexport const RequestStructureSchema = z.discriminatedUnion(\"type\", [\n  HTTPRequestStructureSchema,\n  // MCPRequestStructureSchema,\n  // OpenAPIRequestStructureSchema,\n]);\n\nexport type HTTPRequestStructure = z.infer<typeof HTTPRequestStructureSchema>;\n// export type MCPRequestStructure = z.infer<typeof MCPRequestStructureSchema>;\n// export type OpenAPIRequestStructure = z.infer<typeof OpenAPIRequestStructureSchema>;\nexport type RequestStructure = z.infer<typeof RequestStructureSchema>;\n\n// x402DiscoveryResource\nexport const DiscoveredResourceSchema = z.object({\n  resource: z.string(),\n  type: z.enum([\"http\"]),\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  accepts: z.array(PaymentRequirementsSchema),\n  lastUpdated: z.date(),\n  metadata: z.record(z.any()).optional(),\n});\nexport type DiscoveredResource = z.infer<typeof DiscoveredResourceSchema>;\n\n// x402SettleRequest\nexport const SettleRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type SettleRequest = z.infer<typeof SettleRequestSchema>;\n\n// x402VerifyRequest\nexport const VerifyRequestSchema = z.object({\n  paymentPayload: PaymentPayloadSchema,\n  paymentRequirements: PaymentRequirementsSchema,\n});\nexport type VerifyRequest = z.infer<typeof VerifyRequestSchema>;\n\n// x402VerifyResponse\nexport const VerifyResponseSchema = z.object({\n  isValid: z.boolean(),\n  invalidReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n});\nexport type VerifyResponse = z.infer<typeof VerifyResponseSchema>;\n\n// x402SettleResponse\nexport const SettleResponseSchema = z.object({\n  success: z.boolean(),\n  errorReason: z.enum(ErrorReasons).optional(),\n  payer: EvmOrSvmAddress.optional(),\n  transaction: z.string().regex(MixedAddressRegex),\n  network: NetworkSchema,\n});\nexport type SettleResponse = z.infer<typeof SettleResponseSchema>;\n\n// x402DiscoverListRequest\nexport const ListDiscoveryResourcesRequestSchema = z.object({\n  type: z.string().optional(),\n  limit: z.number().optional(),\n  offset: z.number().optional(),\n});\nexport type ListDiscoveryResourcesRequest = z.infer<typeof ListDiscoveryResourcesRequestSchema>;\n\n// x402ListDiscoveryResourcesResponse\nexport const ListDiscoveryResourcesResponseSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  items: z.array(DiscoveredResourceSchema),\n  pagination: z.object({\n    limit: z.number(),\n    offset: z.number(),\n    total: z.number(),\n  }),\n});\nexport type ListDiscoveryResourcesResponse = z.infer<typeof ListDiscoveryResourcesResponseSchema>;\n\n// x402SupportedPaymentKind\nexport const SupportedPaymentKindSchema = z.object({\n  x402Version: z.number().refine(val => x402Versions.includes(val as 1)),\n  scheme: z.enum(schemes),\n  network: NetworkSchema,\n  extra: z.record(z.any()).optional(),\n});\nexport type SupportedPaymentKind = z.infer<typeof SupportedPaymentKindSchema>;\n\n// x402SupportedPaymentKindsResponse\nexport const SupportedPaymentKindsResponseSchema = z.object({\n  kinds: z.array(SupportedPaymentKindSchema),\n});\nexport type SupportedPaymentKindsResponse = z.infer<typeof SupportedPaymentKindsResponseSchema>;\n","import { z } from \"zod\";\nimport { safeBase64Decode, safeBase64Encode } from \"../../shared\";\nimport { PaymentRequirementsSchema, SettleResponse } from \"./x402Specs\";\n\nexport const facilitatorRequestSchema = z.object({\n  paymentHeader: z.string(),\n  paymentRequirements: PaymentRequirementsSchema,\n});\n\nexport type FacilitatorRequest = z.infer<typeof facilitatorRequestSchema>;\n\n/**\n * Encodes a settlement response into a base64 header string\n *\n * @param response - The settlement response to encode\n * @returns A base64 encoded string containing the settlement response\n */\nexport function settleResponseHeader(response: SettleResponse): string {\n  return safeBase64Encode(JSON.stringify(response));\n}\n\n/**\n * Decodes a base64 header string back into a settlement response\n *\n * @param header - The base64 encoded settlement response header\n * @returns The decoded settlement response object\n */\nexport function settleResponseFromHeader(header: string): SettleResponse {\n  const decoded = safeBase64Decode(header);\n  return JSON.parse(decoded) as SettleResponse;\n}\n","import { Account, Address, Chain, Client, Transport } from \"viem\";\nimport { ChainConfig, config } from \"../../types/shared/evm/config\";\nimport { usdcABI as abi } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC contract address for the current chain from the client\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns The USDC contract address for the current chain\n */\nexport function getUsdcAddress<\n  transport extends Transport,\n  chain extends Chain | undefined = undefined,\n  account extends Account | undefined = undefined,\n>(client: Client<transport, chain, account>): Address {\n  return config[client.chain!.id.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC contract address for a specific chain ID\n *\n * @deprecated Use `getUsdcChainConfigForChain` instead\n * @param chainId - The chain ID to get the USDC contract address for\n * @returns The USDC contract address for the specified chain\n */\nexport function getUsdcAddressForChain(chainId: number): Address {\n  return config[chainId.toString()].usdcAddress as Address;\n}\n\n/**\n * Gets the USDC address and eip712 domain name for a specific chain ID\n *\n * @param chainId - The chain ID\n * @returns The USDC contract address and eip712 domain name  for the specified chain\n */\nexport function getUsdcChainConfigForChain(chainId: number): ChainConfig | undefined {\n  return config[chainId.toString()];\n}\n\n// Cache for storing the version value\nlet versionCache: string | null = null;\n\n/**\n * Gets the version of the USDC contract, using a cache to avoid repeated calls\n *\n * @param client - The Viem client instance connected to the blockchain\n * @returns A promise that resolves to the USDC contract version string\n */\nexport async function getVersion<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>): Promise<string> {\n  // Return cached version if available\n  if (versionCache !== null) {\n    return versionCache;\n  }\n\n  // Fetch and cache version if not available\n  const version = await client.readContract({\n    address: getUsdcAddress(client),\n    abi,\n    functionName: \"version\",\n  });\n  versionCache = version as string;\n  return versionCache;\n}\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getUSDCBalance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(client: ConnectedClient<transport, chain, account>, address: Address): Promise<bigint> {\n  const chainId = client.chain!.id;\n  const usdc = getUsdcChainConfigForChain(chainId);\n  if (!usdc) {\n    return 0n;\n  }\n  const balance = await client.readContract({\n    address: usdc.usdcAddress as `0x${string}`,\n    abi,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","import { Account, Address, Chain, Transport } from \"viem\";\nimport { usdcABI as erc20PermitABI } from \"../../types/shared/evm/erc20PermitABI\";\nimport { ConnectedClient } from \"../../types/shared/evm/wallet\";\n\n/**\n * Gets the USDC balance for a specific address\n *\n * @param client - The Viem client instance connected to the blockchain\n * @param erc20Address - The address of the ERC20 contract\n * @param address - The address to check the USDC balance for\n * @returns A promise that resolves to the USDC balance as a bigint\n */\nexport async function getERC20Balance<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined = undefined,\n>(\n  client: ConnectedClient<transport, chain, account>,\n  erc20Address: Address,\n  address: Address,\n): Promise<bigint> {\n  const balance = await client.readContract({\n    address: erc20Address,\n    abi: erc20PermitABI,\n    functionName: \"balanceOf\",\n    args: [address],\n  });\n  return balance as bigint;\n}\n","import { ExactSvmPayload } from \"../../types/verify/x402Specs\";\nimport {\n  getBase64EncodedWireTransaction,\n  getBase64Encoder,\n  getTransactionDecoder,\n  KeyPairSigner,\n  partiallySignTransaction,\n  RpcDevnet,\n  SolanaRpcApiDevnet,\n  RpcMainnet,\n  SolanaRpcApiMainnet,\n  Transaction,\n} from \"@solana/kit\";\n\n/**\n * Given an object with a base64 encoded transaction, decode the\n * base64 encoded transaction into a solana transaction object.\n *\n * @param svmPayload - The SVM payload to decode\n * @returns The decoded transaction\n */\nexport function decodeTransactionFromPayload(svmPayload: ExactSvmPayload): Transaction {\n  try {\n    const base64Encoder = getBase64Encoder();\n    const transactionBytes = base64Encoder.encode(svmPayload.transaction);\n    const transactionDecoder = getTransactionDecoder();\n    return transactionDecoder.decode(transactionBytes);\n  } catch (error) {\n    console.error(\"error\", error);\n    throw new Error(\"invalid_exact_svm_payload_transaction\");\n  }\n}\n\n/**\n * Sign and simulate a transaction.\n *\n * @param signer - The signer that will sign the transaction\n * @param transaction - The transaction to sign and simulate\n * @param rpc - The RPC client to use to simulate the transaction\n * @returns The transaction simulation result\n */\nexport async function signAndSimulateTransaction(\n  signer: KeyPairSigner,\n  transaction: Transaction,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n) {\n  // sign the transaction as the fee payer\n  const signedTransaction = await partiallySignTransaction([signer.keyPair], transaction);\n\n  // serialize the signed transaction into a base64 encoded wire transaction\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // simulate the transaction and verify that it will succeed\n  const simulateTxConfig = {\n    sigVerify: false,\n    replaceRecentBlockhash: false,\n    commitment: \"confirmed\",\n    encoding: \"base64\",\n    accounts: undefined,\n    innerInstructions: undefined,\n    minContextSlot: undefined,\n  } as const;\n\n  const simulateResult = await rpc\n    .simulateTransaction(base64EncodedTransaction, simulateTxConfig)\n    .send();\n\n  return simulateResult;\n}\n","import { Account, Address, Chain, getAddress, Hex, parseErc6492Signature, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport { getVersion, getERC20Balance } from \"../../../shared/evm\";\nimport {\n  usdcABI as abi,\n  authorizationTypes,\n  config,\n  ConnectedClient,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n  ExactEvmPayload,\n} from \"../../../types/verify\";\nimport { SCHEME } from \"../../exact\";\n\n/**\n * Verifies a payment payload against the required payment details\n *\n * This function performs several verification steps:\n * - Verifies protocol version compatibility\n * - Validates the permit signature\n * - Confirms USDC contract address is correct for the chain\n * - Checks permit deadline is sufficiently in the future\n * - Verifies client has sufficient USDC balance\n * - Ensures payment amount meets required minimum\n *\n * @param client - The public client used for blockchain interactions\n * @param payload - The signed payment payload containing transfer parameters and signature\n * @param paymentRequirements - The payment requirements that the payload must satisfy\n * @returns A ValidPaymentRequest indicating if the payment is valid and any invalidation reason\n */\nexport async function verify<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined,\n>(\n  client: ConnectedClient<transport, chain, account>,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<VerifyResponse> {\n  /* TODO: work with security team on brainstorming more verification steps\n  verification steps:\n    -  verify payload version\n    -  verify usdc address is correct for the chain\n    -  verify permit signature\n    -  verify deadline\n    - verify nonce is current\n    -  verify client has enough funds to cover paymentRequirements.maxAmountRequired\n    -  verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n    - check min amount is above some threshold we think is reasonable for covering gas\n    - verify resource is not already paid for (next version)\n    */\n\n  console.log(\"calling verify evm\");\n\n  const exactEvmPayload = payload.payload as ExactEvmPayload;\n\n  // Verify payload version\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\n    return {\n      isValid: false,\n      invalidReason: `unsupported_scheme`,\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  let name: string;\n  let chainId: number;\n  let erc20Address: Address;\n  let version: string;\n  try {\n    chainId = getNetworkId(payload.network);\n    name = paymentRequirements.extra?.name ?? config[chainId.toString()].usdcName;\n    erc20Address = paymentRequirements.asset as Address;\n    version = paymentRequirements.extra?.version ?? (await getVersion(client));\n  } catch {\n    return {\n      isValid: false,\n      invalidReason: `invalid_network`,\n      payer: (payload.payload as ExactEvmPayload).authorization.from,\n    };\n  }\n  // Verify permit signature is recoverable for the owner address\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const permitTypedData = {\n    types: authorizationTypes,\n    primaryType: \"TransferWithAuthorization\" as const,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: erc20Address,\n    },\n    message: {\n      from: exactEvmPayload.authorization.from,\n      to: exactEvmPayload.authorization.to,\n      value: exactEvmPayload.authorization.value,\n      validAfter: exactEvmPayload.authorization.validAfter,\n      validBefore: exactEvmPayload.authorization.validBefore,\n      nonce: exactEvmPayload.authorization.nonce,\n    },\n  };\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const recoveredAddress = await client.verifyTypedData({\n    address: exactEvmPayload.authorization.from as Address,\n    ...permitTypedData,\n    signature: exactEvmPayload.signature as Hex,\n  });\n  // if (!recoveredAddress) {\n  //   return {\n  //     isValid: false,\n  //     invalidReason: \"invalid_exact_evm_payload_signature\", //\"Invalid permit signature\",\n  //     payer: exactEvmPayload.authorization.from,\n  //   };\n  // }\n\n  // Verify that payment was made to the correct address\n  if (getAddress(exactEvmPayload.authorization.to) !== getAddress(paymentRequirements.payTo)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_recipient_mismatch\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  // Verify deadline is not yet expired\n  // Pad 3 block to account for round tripping\n  if (\n    BigInt(exactEvmPayload.authorization.validBefore) < BigInt(Math.floor(Date.now() / 1000) + 6)\n  ) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_before\", //\"Deadline on permit isn't far enough in the future\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  // Verify deadline is not yet valid\n  if (BigInt(exactEvmPayload.authorization.validAfter) > BigInt(Math.floor(Date.now() / 1000))) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_valid_after\", //\"Deadline on permit is in the future\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  // Verify client has enough funds to cover paymentRequirements.maxAmountRequired\n  const balance = await getERC20Balance(\n    client,\n    erc20Address,\n    exactEvmPayload.authorization.from as Address,\n  );\n  if (balance < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"insufficient_funds\", //\"Client does not have enough funds\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n\n  console.log(\"verify value in payload is enough to cover paymentRequirements.maxAmountRequired\");\n  // Verify value in payload is enough to cover paymentRequirements.maxAmountRequired\n  if (BigInt(exactEvmPayload.authorization.value) < BigInt(paymentRequirements.maxAmountRequired)) {\n    return {\n      isValid: false,\n      invalidReason: \"invalid_exact_evm_payload_authorization_value\", //\"Value in payload is not enough to cover paymentRequirements.maxAmountRequired\",\n      payer: exactEvmPayload.authorization.from,\n    };\n  }\n  return {\n    isValid: true,\n    invalidReason: undefined,\n    payer: exactEvmPayload.authorization.from,\n  };\n}\n\n/**\n * Settles a payment by executing a USDC transferWithAuthorization transaction\n *\n * This function executes the actual USDC transfer using the signed authorization from the user.\n * The facilitator wallet submits the transaction but does not need to hold or transfer any tokens itself.\n *\n * @param wallet - The facilitator wallet that will submit the transaction\n * @param paymentPayload - The signed payment payload containing the transfer parameters and signature\n * @param paymentRequirements - The original payment details that were used to create the payload\n * @returns A PaymentExecutionResponse containing the transaction status and hash\n */\nexport async function settle<transport extends Transport, chain extends Chain>(\n  wallet: SignerWallet<chain, transport>,\n  paymentPayload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<SettleResponse> {\n  const payload = paymentPayload.payload as ExactEvmPayload;\n\n  // re-verify to ensure the payment is still valid\n  const valid = await verify(wallet, paymentPayload, paymentRequirements);\n\n  if (!valid.isValid) {\n    return {\n      success: false,\n      network: paymentPayload.network,\n      transaction: \"\",\n      errorReason: valid.invalidReason ?? \"invalid_scheme\", //`Payment is no longer valid: ${valid.invalidReason}`,\n      payer: payload.authorization.from,\n    };\n  }\n\n  // Returns the original signature (no-op) if the signature is not a 6492 signature\n  const { signature } = parseErc6492Signature(payload.signature as Hex);\n\n  const tx = await wallet.writeContract({\n    address: paymentRequirements.asset as Address,\n    abi,\n    functionName: \"transferWithAuthorization\" as const,\n    args: [\n      payload.authorization.from as Address,\n      payload.authorization.to as Address,\n      BigInt(payload.authorization.value),\n      BigInt(payload.authorization.validAfter),\n      BigInt(payload.authorization.validBefore),\n      payload.authorization.nonce as Hex,\n      signature,\n    ],\n    chain: wallet.chain as Chain,\n  });\n\n  const receipt = await wallet.waitForTransactionReceipt({ hash: tx });\n\n  if (receipt.status !== \"success\") {\n    return {\n      success: false,\n      errorReason: \"invalid_transaction_state\", //`Transaction failed`,\n      transaction: tx,\n      network: paymentPayload.network,\n      payer: payload.authorization.from,\n    };\n  }\n\n  return {\n    success: true,\n    transaction: tx,\n    network: paymentPayload.network,\n    payer: payload.authorization.from,\n  };\n}\n","import {\n  SettleResponse,\n  PaymentPayload,\n  PaymentRequirements,\n  ExactSvmPayload,\n  ErrorReasons,\n} from \"../../../../types/verify\";\nimport {\n  assertIsTransactionMessageWithBlockhashLifetime,\n  Commitment,\n  decompileTransactionMessageFetchingLookupTables,\n  getBase64EncodedWireTransaction,\n  getCompiledTransactionMessageDecoder,\n  getSignatureFromTransaction,\n  isSolanaError,\n  KeyPairSigner,\n  SendTransactionApi,\n  signTransaction,\n  SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcDevnet,\n  RpcMainnet,\n} from \"@solana/kit\";\nimport {\n  decodeTransactionFromPayload,\n  getRpcClient,\n  getRpcSubscriptions,\n} from \"../../../../shared/svm\";\nimport {\n  createBlockHeightExceedencePromiseFactory,\n  waitForRecentTransactionConfirmation,\n  createRecentSignatureConfirmationPromiseFactory,\n} from \"@solana/transaction-confirmation\";\nimport { verify } from \"./verify\";\n\n/**\n * Settle the payment payload against the payment requirements.\n * TODO: handle durable nonce lifetime transactions\n *\n * @param signer - The signer that will sign the transaction\n * @param payload - The payment payload to settle\n * @param paymentRequirements - The payment requirements to settle against\n * @returns A SettleResponse indicating if the payment is settled and any error reason\n */\nexport async function settle(\n  signer: KeyPairSigner,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<SettleResponse> {\n  const verifyResponse = await verify(signer, payload, paymentRequirements);\n  if (!verifyResponse.isValid) {\n    return {\n      success: false,\n      errorReason: verifyResponse.invalidReason,\n      network: payload.network,\n      transaction: \"\",\n    };\n  }\n\n  const svmPayload = payload.payload as ExactSvmPayload;\n  const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n  const signedTransaction = await signTransaction([signer.keyPair], decodedTransaction);\n  const payer = signer.address.toString();\n\n  const rpc = getRpcClient(payload.network);\n  const rpcSubscriptions = getRpcSubscriptions(payload.network);\n\n  try {\n    const { success, errorReason, signature } = await sendAndConfirmSignedTransaction(\n      signedTransaction,\n      rpc,\n      rpcSubscriptions,\n    );\n\n    return {\n      success,\n      errorReason,\n      payer,\n      transaction: signature,\n      network: payload.network,\n    };\n  } catch (error) {\n    console.error(\"Unexpected error during transaction settlement:\", error);\n    return {\n      success: false,\n      errorReason: \"unexpected_settle_error\",\n      network: payload.network,\n      transaction: getSignatureFromTransaction(signedTransaction),\n    };\n  }\n}\n\n/**\n * Send a signed transaction to the RPC.\n * TODO: should this be moved to the shared/svm/rpc.ts file?\n *\n * @param signedTransaction - The signed transaction to send\n * @param rpc - The RPC client to use to send the transaction\n * @param sendTxConfig - The configuration for the transaction send\n * @returns The signature of the sent transaction\n */\nexport async function sendSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  sendTxConfig: Parameters<SendTransactionApi[\"sendTransaction\"]>[1] = {\n    skipPreflight: true,\n    encoding: \"base64\",\n  },\n): Promise<string> {\n  const base64EncodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n  return await rpc.sendTransaction(base64EncodedTransaction, sendTxConfig).send();\n}\n\n/**\n * Confirm a signed transaction.\n * TODO: can some of this be refactored to be moved to the shared/svm/rpc.ts file?\n * TODO: should the commitment and the timeout be passed in as parameters?\n *\n * @param signedTransaction - The signed transaction to confirm\n * @param rpc - The RPC client to use to confirm the transaction\n * @param rpcSubscriptions - The RPC subscriptions to use to confirm the transaction\n * @returns The success and signature of the confirmed transaction\n */\nexport async function confirmSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  rpcSubscriptions: ReturnType<typeof getRpcSubscriptions>,\n): Promise<{ success: boolean; errorReason?: (typeof ErrorReasons)[number]; signature: string }> {\n  // get the signature from the signed transaction\n  const signature = getSignatureFromTransaction(signedTransaction);\n\n  // set a timeout for the transaction confirmation\n  const abortController = new AbortController();\n  const timeout = setTimeout(() => {\n    abortController.abort(\"Transaction confirmation timed out after 60 seconds\");\n  }, 60000);\n\n  try {\n    // decompile the transaction message to get the blockhash lifetime\n    const compiledTransactionMessage = getCompiledTransactionMessageDecoder().decode(\n      signedTransaction.messageBytes,\n    );\n    const decompiledTransactionMessage = await decompileTransactionMessageFetchingLookupTables(\n      compiledTransactionMessage,\n      rpc,\n    );\n    assertIsTransactionMessageWithBlockhashLifetime(decompiledTransactionMessage);\n\n    // add the blockhash lifetime to the signed transaction\n    const signedTransactionWithBlockhashLifetime = {\n      ...signedTransaction,\n      lifetimeConstraint: decompiledTransactionMessage.lifetimeConstraint,\n    };\n\n    // create the config for the transaction confirmation\n    const commitment: Commitment = \"confirmed\";\n\n    const getRecentSignatureConfirmationPromise = createRecentSignatureConfirmationPromiseFactory({\n      rpc,\n      rpcSubscriptions,\n    } as Parameters<typeof createRecentSignatureConfirmationPromiseFactory>[0]);\n\n    const getBlockHeightExceedencePromise = createBlockHeightExceedencePromiseFactory({\n      rpc,\n      rpcSubscriptions,\n    } as Parameters<typeof createBlockHeightExceedencePromiseFactory>[0]);\n\n    const config = {\n      abortSignal: abortController.signal,\n      commitment,\n      getBlockHeightExceedencePromise,\n      getRecentSignatureConfirmationPromise,\n    };\n\n    // wait for the transaction to be confirmed\n    await waitForRecentTransactionConfirmation({\n      ...config,\n      transaction: signedTransactionWithBlockhashLifetime,\n    });\n\n    // return the success and signature\n    return {\n      success: true,\n      signature,\n    };\n  } catch (error) {\n    console.error(error);\n\n    // block height exceeded error\n    if (isSolanaError(error, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED)) {\n      return {\n        success: false,\n        errorReason: \"settle_exact_svm_block_height_exceeded\",\n        signature,\n      };\n    }\n    // transaction confirmation timed out error\n    else if (error instanceof DOMException && error.name === \"AbortError\") {\n      return {\n        success: false,\n        errorReason: \"settle_exact_svm_transaction_confirmation_timed_out\",\n        signature,\n      };\n    }\n    // unexpected error\n    else {\n      throw error;\n    }\n  } finally {\n    // clear the timeout\n    clearTimeout(timeout);\n  }\n}\n\n/**\n * Send and confirm a signed transaction.\n *\n * @param signedTransaction - The signed transaction to send and confirm\n * @param rpc - The RPC client to use to send and confirm the transaction\n * @param rpcSubscriptions - The RPC subscriptions to use to send and confirm the transaction\n * @returns The success and signature of the confirmed transaction\n */\nexport async function sendAndConfirmSignedTransaction(\n  signedTransaction: Awaited<ReturnType<typeof signTransaction>>,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n  rpcSubscriptions: ReturnType<typeof getRpcSubscriptions>,\n): Promise<{ success: boolean; errorReason?: (typeof ErrorReasons)[number]; signature: string }> {\n  await sendSignedTransaction(signedTransaction, rpc);\n  return await confirmSignedTransaction(signedTransaction, rpc, rpcSubscriptions);\n}\n","import {\n  VerifyResponse,\n  PaymentPayload,\n  PaymentRequirements,\n  ExactSvmPayload,\n  ErrorReasons,\n} from \"../../../../types/verify\";\nimport { SupportedSVMNetworks } from \"../../../../types/shared\";\nimport {\n  Address,\n  assertIsInstructionWithAccounts,\n  assertIsInstructionWithData,\n  CompilableTransactionMessage,\n  decompileTransactionMessageFetchingLookupTables,\n  fetchEncodedAccounts,\n  getCompiledTransactionMessageDecoder,\n  KeyPairSigner,\n  SolanaRpcApiDevnet,\n  SolanaRpcApiMainnet,\n  RpcDevnet,\n  RpcMainnet,\n  Instruction,\n  AccountLookupMeta,\n  AccountMeta,\n  InstructionWithData,\n} from \"@solana/kit\";\nimport {\n  parseSetComputeUnitLimitInstruction,\n  parseSetComputeUnitPriceInstruction,\n  COMPUTE_BUDGET_PROGRAM_ADDRESS,\n} from \"@solana-program/compute-budget\";\nimport {\n  findAssociatedTokenPda,\n  identifyToken2022Instruction,\n  parseCreateAssociatedTokenInstruction,\n  parseTransferCheckedInstruction as parseTransferCheckedInstruction2022,\n  Token2022Instruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport {\n  identifyTokenInstruction,\n  parseTransferCheckedInstruction as parseTransferCheckedInstructionToken,\n  TOKEN_PROGRAM_ADDRESS,\n  TokenInstruction,\n} from \"@solana-program/token\";\nimport {\n  decodeTransactionFromPayload,\n  getRpcClient,\n  signAndSimulateTransaction,\n} from \"../../../../shared/svm\";\nimport { SCHEME } from \"../../\";\n\n/**\n * Verify the payment payload against the payment requirements.\n *\n * @param signer - The signer that will sign and simulate the transaction\n * @param payload - The payment payload to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @returns A VerifyResponse indicating if the payment is valid and any invalidation reason\n */\nexport async function verify(\n  signer: KeyPairSigner,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<VerifyResponse> {\n  try {\n    // verify that the scheme and network are supported\n    verifySchemesAndNetworks(payload, paymentRequirements);\n\n    // decode the base64 encoded transaction\n    const svmPayload = payload.payload as ExactSvmPayload;\n    const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n    const rpc = getRpcClient(payload.network);\n\n    // perform transaction introspection to validate the transaction structure and details\n    await transactionIntrospection(svmPayload, paymentRequirements, rpc);\n\n    // simulate the transaction to ensure it will execute successfully\n    const simulateResult = await signAndSimulateTransaction(signer, decodedTransaction, rpc);\n    if (simulateResult.value?.err) {\n      throw new Error(`invalid_exact_svm_payload_transaction_simulation_failed`);\n    }\n\n    return {\n      isValid: true,\n      invalidReason: undefined,\n    };\n  } catch (error) {\n    // if the error is one of the known error reasons, return the error reason\n    if (error instanceof Error) {\n      if (ErrorReasons.includes(error.message as (typeof ErrorReasons)[number])) {\n        return {\n          isValid: false,\n          invalidReason: error.message as (typeof ErrorReasons)[number],\n        };\n      }\n    }\n\n    // if the error is not one of the known error reasons, return an unexpected error reason\n    console.error(error);\n    return {\n      isValid: false,\n      invalidReason: \"unexpected_verify_error\",\n    };\n  }\n}\n\n/**\n * Verify that the scheme and network are supported.\n *\n * @param payload - The payment payload to verify\n * @param paymentRequirements - The payment requirements to verify against\n */\nexport function verifySchemesAndNetworks(\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): void {\n  if (payload.scheme !== SCHEME || paymentRequirements.scheme !== SCHEME) {\n    throw new Error(\"unsupported_scheme\");\n  }\n\n  if (\n    payload.network !== paymentRequirements.network ||\n    !SupportedSVMNetworks.includes(paymentRequirements.network)\n  ) {\n    throw new Error(\"invalid_network\");\n  }\n}\n\n/**\n * Perform transaction introspection to validate the transaction structure and transfer details.\n * This function handles decoding the transaction, validating the transfer instruction,\n * and verifying all transfer details against the payment requirements.\n *\n * @param svmPayload - The SVM payload containing the transaction\n * @param paymentRequirements - The payment requirements to verify against\n * @param rpc - The RPC client to use for fetching token and ATA information\n */\nexport async function transactionIntrospection(\n  svmPayload: ExactSvmPayload,\n  paymentRequirements: PaymentRequirements,\n  rpc: RpcDevnet<SolanaRpcApiDevnet> | RpcMainnet<SolanaRpcApiMainnet>,\n): Promise<void> {\n  const decodedTransaction = decodeTransactionFromPayload(svmPayload);\n  const compiledTransactionMessage = getCompiledTransactionMessageDecoder().decode(\n    decodedTransaction.messageBytes,\n  );\n  const transactionMessage = await decompileTransactionMessageFetchingLookupTables(\n    compiledTransactionMessage,\n    rpc,\n  );\n\n  // verify that the transaction contains the expected instructions\n  await verifyTransactionInstructions(transactionMessage, paymentRequirements);\n}\n\n/**\n * Verify that the transaction contains the expected instructions.\n *\n * @param transactionMessage - The transaction message to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @throws Error if the transaction does not contain the expected instructions\n */\nexport async function verifyTransactionInstructions(\n  transactionMessage: CompilableTransactionMessage,\n  paymentRequirements: PaymentRequirements,\n) {\n  // validate the number of expected instructions\n  if (\n    transactionMessage.instructions.length !== 3 &&\n    transactionMessage.instructions.length !== 4\n  ) {\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_length`);\n  }\n\n  // verify that the compute limit and price instructions are valid\n  verifyComputeLimitInstruction(transactionMessage.instructions[0]);\n  verifyComputePriceInstruction(transactionMessage.instructions[1]);\n\n  // verify that the transfer instruction is valid\n  // this expects the destination ATA to already exist\n  if (transactionMessage.instructions.length === 3) {\n    await verifyTransferInstruction(transactionMessage.instructions[2], paymentRequirements, {\n      txHasCreateDestATAInstruction: false,\n    });\n  }\n\n  // verify that the transfer instruction is valid\n  // this expects the destination ATA to be created in the same transaction\n  else {\n    verifyCreateATAInstruction(transactionMessage.instructions[2], paymentRequirements);\n    verifyTransferInstruction(transactionMessage.instructions[3], paymentRequirements, {\n      txHasCreateDestATAInstruction: true,\n    });\n  }\n}\n\n/**\n * Verify that the compute limit instruction is valid.\n *\n * @param instruction - The compute limit instruction to verify\n * @throws Error if the compute limit instruction is invalid\n */\nexport function verifyComputeLimitInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  try {\n    if (\n      instruction.programAddress.toString() !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n      instruction.data?.[0] !== 2 // discriminator of set compute unit limit instruction\n    ) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction`,\n      );\n    }\n    parseSetComputeUnitLimitInstruction(\n      instruction as InstructionWithData<Uint8Array<ArrayBufferLike>>,\n    );\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_compute_limit_instruction`);\n  }\n}\n\n/**\n * Verify that the compute price instruction is valid.\n * This function throws an error if the compute unit price is greater than 5 lamports,\n * to protect the facilitator against gas fee abuse from the client.\n *\n * @param instruction - The compute price instruction to verify\n * @throws Error if the compute price instruction is invalid\n */\nexport function verifyComputePriceInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  if (\n    instruction.programAddress.toString() !== COMPUTE_BUDGET_PROGRAM_ADDRESS.toString() ||\n    instruction.data?.[0] !== 3 // discriminator of set compute unit price instruction\n  ) {\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions_compute_price_instruction`);\n  }\n  const parsedInstruction = parseSetComputeUnitPriceInstruction(\n    instruction as InstructionWithData<Uint8Array<ArrayBufferLike>>,\n  );\n\n  // TODO: allow the facilitator to pass in an optional max compute unit price\n  if (parsedInstruction.data.microLamports > 5 * 1_000_000) {\n    throw new Error(\n      `invalid_exact_svm_payload_transaction_instructions_compute_price_instruction_too_high`,\n    );\n  }\n}\n\n/**\n * Verify that the create ATA instruction is valid.\n *\n * @param instruction - The create ATA instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @throws Error if the create ATA instruction is invalid\n */\nexport function verifyCreateATAInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n  paymentRequirements: PaymentRequirements,\n) {\n  let createATAInstruction: ReturnType<typeof parseCreateAssociatedTokenInstruction>;\n\n  // validate and refine the type of the create ATA instruction\n  try {\n    assertIsInstructionWithAccounts(instruction);\n    assertIsInstructionWithData(instruction);\n\n    // parse the create ATA instruction\n    createATAInstruction = parseCreateAssociatedTokenInstruction({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction`);\n  }\n\n  // verify that the ATA is created for the expected payee\n  if (createATAInstruction.accounts.owner.address !== paymentRequirements.payTo) {\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_payee`);\n  }\n\n  // verify that the ATA is created for the expected asset\n  if (createATAInstruction.accounts.mint.address !== paymentRequirements.asset) {\n    throw new Error(`invalid_exact_svm_payload_transaction_create_ata_instruction_incorrect_asset`);\n  }\n}\n\n/**\n * Verify that the transfer instruction is valid.\n *\n * @param instruction - The transfer instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param {object} options - The options for the verification of the transfer instruction\n * @param {boolean} options.txHasCreateDestATAInstruction - Whether the transaction has a create destination ATA instruction\n * @throws Error if the transfer instruction is invalid\n */\nexport async function verifyTransferInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n  paymentRequirements: PaymentRequirements,\n  { txHasCreateDestATAInstruction }: { txHasCreateDestATAInstruction: boolean },\n) {\n  // get a validated and parsed transferChecked instruction\n  const tokenInstruction = getValidatedTransferCheckedInstruction(instruction);\n  await verifyTransferCheckedInstruction(tokenInstruction, paymentRequirements, {\n    txHasCreateDestATAInstruction,\n  });\n}\n\n/**\n * Verify that the transfer checked instruction is valid.\n *\n * @param parsedInstruction - The parsed transfer checked instruction to verify\n * @param paymentRequirements - The payment requirements to verify against\n * @param {object} options - The options for the verification of the transfer checked instruction\n * @param {boolean} options.txHasCreateDestATAInstruction - Whether the transaction has a create destination ATA instruction\n * @throws Error if the transfer checked instruction is invalid\n */\nexport async function verifyTransferCheckedInstruction(\n  parsedInstruction: ReturnType<typeof parseTransferCheckedInstruction2022>,\n  paymentRequirements: PaymentRequirements,\n  { txHasCreateDestATAInstruction }: { txHasCreateDestATAInstruction: boolean },\n) {\n  // get the token program address\n  const tokenProgramAddress =\n    parsedInstruction.programAddress.toString() === TOKEN_PROGRAM_ADDRESS.toString()\n      ? TOKEN_PROGRAM_ADDRESS\n      : TOKEN_2022_PROGRAM_ADDRESS;\n\n  // get the expected receiver's ATA\n  const payToATA = await findAssociatedTokenPda({\n    mint: paymentRequirements.asset as Address,\n    owner: paymentRequirements.payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  // verify that the transfer is to the expected ATA\n  if (parsedInstruction.accounts.destination.address !== payToATA[0]) {\n    throw new Error(`invalid_exact_svm_payload_transaction_transfer_to_incorrect_ata`);\n  }\n\n  // verify that the source and destination ATAs exist\n  const addresses = [parsedInstruction.accounts.source.address, payToATA[0]];\n  const rpc = getRpcClient(paymentRequirements.network);\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses);\n  const missingAccounts = maybeAccounts.filter(a => !a.exists);\n  for (const missingAccount of missingAccounts) {\n    if (missingAccount.address === parsedInstruction.accounts.source.address) {\n      throw new Error(`invalid_exact_svm_payload_transaction_sender_ata_not_found`);\n    }\n    if (missingAccount.address === payToATA[0] && !txHasCreateDestATAInstruction) {\n      throw new Error(`invalid_exact_svm_payload_transaction_receiver_ata_not_found`);\n    }\n  }\n\n  // verify that the amount is correct\n  const instructionAmount = parsedInstruction.data.amount;\n  const paymentRequirementsAmount = BigInt(paymentRequirements.maxAmountRequired);\n  if (instructionAmount !== paymentRequirementsAmount) {\n    throw new Error(`invalid_exact_svm_payload_transaction_amount_mismatch`);\n  }\n}\n\n/**\n * Inspect the decompiled transaction message to make sure that it is a valid\n * transfer instruction.\n *\n * @param instruction - The instruction to get the transfer instruction from\n * @returns The validated transfer instruction\n * @throws Error if the instruction is not a valid transfer checked instruction\n */\nexport function getValidatedTransferCheckedInstruction(\n  instruction: Instruction<\n    string,\n    readonly (AccountLookupMeta<string, string> | AccountMeta<string>)[]\n  >,\n) {\n  try {\n    assertIsInstructionWithData(instruction);\n    assertIsInstructionWithAccounts(instruction);\n  } catch (error) {\n    console.error(error);\n    throw new Error(`invalid_exact_svm_payload_transaction_instructions`);\n  }\n\n  let tokenInstruction;\n\n  // spl-token program\n  if (instruction.programAddress.toString() === TOKEN_PROGRAM_ADDRESS.toString()) {\n    const identifiedInstruction = identifyTokenInstruction(instruction);\n    if (identifiedInstruction !== TokenInstruction.TransferChecked) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instruction_not_spl_token_transfer_checked`,\n      );\n    }\n    tokenInstruction = parseTransferCheckedInstructionToken({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  }\n  // token-2022 program\n  else if (instruction.programAddress.toString() === TOKEN_2022_PROGRAM_ADDRESS.toString()) {\n    const identifiedInstruction = identifyToken2022Instruction(instruction);\n    if (identifiedInstruction !== Token2022Instruction.TransferChecked) {\n      throw new Error(\n        `invalid_exact_svm_payload_transaction_instruction_not_token_2022_transfer_checked`,\n      );\n    }\n    tokenInstruction = parseTransferCheckedInstruction2022({\n      ...instruction,\n      data: new Uint8Array(instruction.data),\n    });\n  }\n  // invalid instruction\n  else {\n    throw new Error(`invalid_exact_svm_payload_transaction_not_a_transfer_instruction`);\n  }\n\n  return tokenInstruction;\n}\n","import { encodePayment } from \"../../utils\";\nimport {\n  Address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction,\n  type KeyPairSigner,\n  fetchEncodedAccount,\n  TransactionSigner,\n  Instruction,\n} from \"@solana/kit\";\nimport { PaymentPayload, PaymentRequirements } from \"../../../types/verify\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenInstruction,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { getRpcClient } from \"../../../shared/svm/rpc\";\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to a base64 encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const paymentPayload = await createAndSignPayment(client, x402Version, paymentRequirements);\n  return encodePayment(paymentPayload);\n}\n\n/**\n * Creates and signs a payment for the given client and payment requirements.\n *\n * @param client - The signer instance used to create and sign the payment tx\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to a payment payload containing a base64 encoded solana token transfer tx\n */\nexport async function createAndSignPayment(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const transactionMessage = await createTransferTransactionMessage(client, paymentRequirements);\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // return payment payload\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version: x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction,\n    },\n  } as PaymentPayload;\n}\n\n/**\n * Creates a transfer transaction message for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the transfer transaction message\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to the transaction message with the transfer instruction\n */\nasync function createTransferTransactionMessage(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n) {\n  const rpc = getRpcClient(paymentRequirements.network);\n\n  // create the transfer instruction\n  const transferInstructions = await createAtaAndTransferInstructions(client, paymentRequirements);\n\n  // create tx to simulate\n  const feePayer = paymentRequirements.extra?.feePayer as Address;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageComputeUnitPrice(1, tx), // 1 microlamport priority fee\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => appendTransactionMessageInstructions(transferInstructions, tx),\n  );\n\n  // estimate the compute budget limit (gas limit)\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n\n  // finalize the transaction message by adding the compute budget limit and blockhash\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    tx =>\n      prependTransactionMessageInstruction(\n        getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n        tx,\n      ),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n\n  return tx;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will determine which transfer instruction to create\n * based on the program that created the token (token-2022 or token).\n *\n * @param client - The signer instance used to create the transfer instruction\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to the create ATA (if needed) and transfer instruction\n */\nasync function createAtaAndTransferInstructions(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n): Promise<Instruction[]> {\n  const { asset } = paymentRequirements;\n\n  const rpc = getRpcClient(paymentRequirements.network);\n  const tokenMint = await fetchMint(rpc, asset as Address);\n  const tokenProgramAddress = tokenMint.programAddress;\n\n  // validate that the asset was created by a known token program\n  if (\n    tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n    tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n  ) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n\n  const instructions: Instruction[] = [];\n\n  // create the ATA (if needed)\n  const createAtaIx = await createAtaInstructionOrUndefined(\n    paymentRequirements,\n    tokenProgramAddress,\n  );\n  if (createAtaIx) {\n    instructions.push(createAtaIx);\n  }\n\n  // create the transfer instruction\n  const transferIx = await createTransferInstruction(\n    client,\n    paymentRequirements,\n    tokenMint.data.decimals,\n    tokenProgramAddress,\n  );\n  instructions.push(transferIx);\n\n  return instructions;\n}\n\n/**\n * Returns a create ATA instruction for the payTo address if the ATA account does not exist.\n * The create ATA instruction will be paid for by the feePayer in the payment requirements.\n *\n * This function will work for both spl-token and token-2022.\n *\n * Returns undefined if the ATA account already exists.\n *\n * @param paymentRequirements - The payment requirements\n * @param tokenProgramAddress - The address of the token program\n * @returns A promise that resolves to the create ATA instruction or undefined if the ATA account already exists\n * @throws an error if the feePayer is not provided in the payment requirements\n */\nasync function createAtaInstructionOrUndefined(\n  paymentRequirements: PaymentRequirements,\n  tokenProgramAddress: Address,\n): Promise<Instruction | undefined> {\n  const { asset, payTo, extra, network } = paymentRequirements;\n  const feePayer = extra?.feePayer as Address;\n\n  // feePayer is required\n  if (!feePayer) {\n    throw new Error(\n      \"feePayer is required in paymentRequirements.extra in order to set the \" +\n        \"facilitator as the fee payer for the create associated token account instruction\",\n    );\n  }\n\n  // derive the ATA of the payTo address\n  const [destinationATAAddress] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  // check if the ATA exists\n  const rpc = getRpcClient(network);\n  const maybeAccount = await fetchEncodedAccount(rpc, destinationATAAddress);\n\n  // if the ATA does not exist, return an instruction to create it\n  if (!maybeAccount.exists) {\n    return getCreateAssociatedTokenInstruction({\n      payer: paymentRequirements.extra?.feePayer as TransactionSigner<string>,\n      ata: destinationATAAddress,\n      owner: payTo as Address,\n      mint: asset as Address,\n      tokenProgram: tokenProgramAddress,\n    });\n  }\n\n  // if the ATA exists, return undefined\n  return undefined;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will create a transfer instruction for a token created by either\n * the token program or the token-2022 program.\n *\n * @param client - The signer instance who's tokens will be debited from\n * @param paymentRequirements - The payment requirements\n * @param decimals - The decimals of the token\n * @param tokenProgramAddress - The address of the token program\n * @returns A promise that resolves to the transfer instruction\n */\nasync function createTransferInstruction(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n  decimals: number,\n  tokenProgramAddress: Address,\n): Promise<Instruction> {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  return getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset as Address,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: decimals,\n    },\n    { programAddress: tokenProgramAddress },\n  );\n}\n","export * as evm from \"./evm\";\nexport * as svm from \"./svm\";\n\nexport const SCHEME = \"exact\";\n","import { verify as verifyExactEvm, settle as settleExactEvm } from \"../schemes/exact/evm\";\nimport { verify as verifyExactSvm, settle as settleExactSvm } from \"../schemes/exact/svm\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"../types/shared\";\nimport {\n  ConnectedClient as EvmConnectedClient,\n  SignerWallet as EvmSignerWallet,\n} from \"../types/shared/evm\";\nimport { ConnectedClient, Signer } from \"../types/shared/wallet\";\nimport {\n  PaymentPayload,\n  PaymentRequirements,\n  SettleResponse,\n  VerifyResponse,\n  ExactEvmPayload,\n} from \"../types/verify\";\nimport { Chain, Transport, Account } from \"viem\";\nimport { KeyPairSigner } from \"@solana/kit\";\n\n/**\n * Verifies a payment payload against the required payment details regardless of the scheme\n * this function wraps all verify functions for each specific scheme\n *\n * @param client - The public client used for blockchain interactions\n * @param payload - The signed payment payload containing transfer parameters and signature\n * @param paymentRequirements - The payment requirements that the payload must satisfy\n * @returns A ValidPaymentRequest indicating if the payment is valid and any invalidation reason\n */\nexport async function verify<\n  transport extends Transport,\n  chain extends Chain,\n  account extends Account | undefined,\n>(\n  client: ConnectedClient | Signer,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<VerifyResponse> {\n  // exact scheme\n  if (paymentRequirements.scheme === \"exact\") {\n    // evm\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      return verifyExactEvm(\n        client as EvmConnectedClient<transport, chain, account>,\n        payload,\n        paymentRequirements,\n      );\n    }\n\n    // svm\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      return await verifyExactSvm(client as KeyPairSigner, payload, paymentRequirements);\n    }\n  }\n\n  // unsupported scheme\n  return {\n    isValid: false,\n    invalidReason: \"invalid_scheme\",\n    payer: SupportedEVMNetworks.includes(paymentRequirements.network)\n      ? (payload.payload as ExactEvmPayload).authorization.from\n      : \"\",\n  };\n}\n\n/**\n * Settles a payment payload against the required payment details regardless of the scheme\n * this function wraps all settle functions for each specific scheme\n *\n * @param client - The signer wallet used for blockchain interactions\n * @param payload - The signed payment payload containing transfer parameters and signature\n * @param paymentRequirements - The payment requirements that the payload must satisfy\n * @returns A SettleResponse indicating if the payment is settled and any settlement reason\n */\nexport async function settle<transport extends Transport, chain extends Chain>(\n  client: Signer,\n  payload: PaymentPayload,\n  paymentRequirements: PaymentRequirements,\n): Promise<SettleResponse> {\n  // exact scheme\n  if (paymentRequirements.scheme === \"exact\") {\n    // evm\n    if (SupportedEVMNetworks.includes(paymentRequirements.network)) {\n      return await settleExactEvm(\n        client as EvmSignerWallet<chain, transport>,\n        payload,\n        paymentRequirements,\n      );\n    }\n\n    // svm\n    if (SupportedSVMNetworks.includes(paymentRequirements.network)) {\n      return await settleExactSvm(client as KeyPairSigner, payload, paymentRequirements);\n    }\n  }\n\n  return {\n    success: false,\n    errorReason: \"invalid_scheme\",\n    transaction: \"\",\n    network: paymentRequirements.network,\n    payer: SupportedEVMNetworks.includes(paymentRequirements.network)\n      ? (payload.payload as ExactEvmPayload).authorization.from\n      : \"\",\n  };\n}\n\nexport type Supported = {\n  x402Version: number;\n  kind: {\n    scheme: string;\n    networkId: string;\n    extra: object;\n  }[];\n};\n"],"mappings":"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","names":["settle","verify","import_viem","import_zod","import_kit","import_zod","import_zod","import_kit","import_viem","import_kit","import_kit","parseTransferCheckedInstructionToken","parseTransferCheckedInstruction2022","config","import_kit","import_token_2022","import_token","import_compute_budget","verify","settle","verify","settle"]}