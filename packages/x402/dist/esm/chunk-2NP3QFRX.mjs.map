{"version":3,"sources":["../../src/schemes/exact/evm/utils/paymentUtils.ts","../../src/schemes/exact/evm/sign.ts","../../src/schemes/exact/evm/client.ts","../../src/schemes/exact/svm/client.ts"],"sourcesContent":["import { safeBase64Encode, safeBase64Decode } from \"../../../../shared\";\nimport { SupportedEVMNetworks, SupportedSVMNetworks } from \"../../../../types\";\nimport {\n  PaymentPayload,\n  PaymentPayloadSchema,\n  ExactEvmPayload,\n  ExactSvmPayload,\n} from \"../../../../types/verify\";\n\n/**\n * Encodes a payment payload into a base64 string, ensuring bigint values are properly stringified\n *\n * @param payment - The payment payload to encode\n * @returns A base64 encoded string representation of the payment payload\n */\nexport function encodePayment(payment: PaymentPayload): string {\n  let safe: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(payment.network)) {\n    const evmPayload = payment.payload as ExactEvmPayload;\n    safe = {\n      ...payment,\n      payload: {\n        ...evmPayload,\n        authorization: Object.fromEntries(\n          Object.entries(evmPayload.authorization).map(([key, value]) => [\n            key,\n            typeof value === \"bigint\" ? (value as bigint).toString() : value,\n          ]),\n        ) as ExactEvmPayload[\"authorization\"],\n      },\n    };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  // svm\n  if (SupportedSVMNetworks.includes(payment.network)) {\n    safe = { ...payment, payload: payment.payload as ExactSvmPayload };\n    return safeBase64Encode(JSON.stringify(safe));\n  }\n\n  throw new Error(\"Invalid network\");\n}\n\n/**\n * Decodes a base64 encoded payment string back into a PaymentPayload object\n *\n * @param payment - The base64 encoded payment string to decode\n * @returns The decoded and validated PaymentPayload object\n */\nexport function decodePayment(payment: string): PaymentPayload {\n  const decoded = safeBase64Decode(payment);\n  const parsed = JSON.parse(decoded);\n\n  let obj: PaymentPayload;\n\n  // evm\n  if (SupportedEVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactEvmPayload,\n    };\n  }\n\n  // svm\n  else if (SupportedSVMNetworks.includes(parsed.network)) {\n    obj = {\n      ...parsed,\n      payload: parsed.payload as ExactSvmPayload,\n    };\n  } else {\n    throw new Error(\"Invalid network\");\n  }\n\n  const validated = PaymentPayloadSchema.parse(obj);\n  return validated;\n}\n","import { Chain, getAddress, Hex, LocalAccount, toHex, Transport } from \"viem\";\nimport { getNetworkId } from \"../../../shared\";\nimport {\n  authorizationTypes,\n  isAccount,\n  isSignerWallet,\n  SignerWallet,\n} from \"../../../types/shared/evm\";\nimport { ExactEvmPayloadAuthorization, PaymentRequirements } from \"../../../types/verify\";\n\n/**\n * Signs an EIP-3009 authorization for USDC transfer\n *\n * @param walletClient - The wallet client that will sign the authorization\n * @param params - The authorization parameters containing transfer details\n * @param params.from - The address tokens will be transferred from\n * @param params.to - The address tokens will be transferred to\n * @param params.value - The amount of USDC tokens to transfer (in base units)\n * @param params.validAfter - Unix timestamp after which the authorization becomes valid\n * @param params.validBefore - Unix timestamp before which the authorization is valid\n * @param params.nonce - Random 32-byte nonce to prevent replay attacks\n * @param paymentRequirements - The payment requirements containing asset and network information\n * @param paymentRequirements.asset - The address of the USDC contract\n * @param paymentRequirements.network - The network where the USDC contract exists\n * @param paymentRequirements.extra - The extra information containing the name and version of the ERC20 contract\n * @returns The signature for the authorization\n */\nexport async function signAuthorization<transport extends Transport, chain extends Chain>(\n  walletClient: SignerWallet<chain, transport> | LocalAccount,\n  { from, to, value, validAfter, validBefore, nonce }: ExactEvmPayloadAuthorization,\n  { asset, network, extra }: PaymentRequirements,\n): Promise<{ signature: Hex }> {\n  const chainId = getNetworkId(network);\n  const name = extra?.name;\n  const version = extra?.version;\n\n  const data = {\n    types: authorizationTypes,\n    domain: {\n      name,\n      version,\n      chainId,\n      verifyingContract: getAddress(asset),\n    },\n    primaryType: \"TransferWithAuthorization\" as const,\n    message: {\n      from: getAddress(from),\n      to: getAddress(to),\n      value,\n      validAfter,\n      validBefore,\n      nonce: nonce,\n    },\n  };\n\n  if (isSignerWallet(walletClient)) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else if (isAccount(walletClient) && walletClient.signTypedData) {\n    const signature = await walletClient.signTypedData(data);\n    return {\n      signature,\n    };\n  } else {\n    throw new Error(\"Invalid wallet client provided does not support signTypedData\");\n  }\n}\n\n/**\n * Generates a random 32-byte nonce for use in authorization signatures\n *\n * @returns A random 32-byte nonce as a hex string\n */\nexport function createNonce(): Hex {\n  const cryptoObj =\n    typeof globalThis.crypto !== \"undefined\" &&\n    typeof globalThis.crypto.getRandomValues === \"function\"\n      ? globalThis.crypto\n      : // Dynamic require is needed to support node.js\n        // eslint-disable-next-line @typescript-eslint/no-require-imports\n        require(\"crypto\").webcrypto;\n  return toHex(cryptoObj.getRandomValues(new Uint8Array(32)));\n}\n","import { Address, Chain, LocalAccount, Transport } from \"viem\";\nimport { isSignerWallet, SignerWallet } from \"../../../types/shared/evm\";\nimport { PaymentPayload, PaymentRequirements, UnsignedPaymentPayload } from \"../../../types/verify\";\nimport { createNonce, signAuthorization } from \"./sign\";\nimport { encodePayment } from \"./utils/paymentUtils\";\n\n/**\n * Prepares an unsigned payment header with the given sender address and payment requirements.\n *\n * @param from - The sender's address from which the payment will be made\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns An unsigned payment payload containing authorization details\n */\nexport function preparePaymentHeader(\n  from: Address,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): UnsignedPaymentPayload {\n  const nonce = createNonce();\n\n  const validAfter = BigInt(\n    Math.floor(Date.now() / 1000) - 600, // 10 minutes before\n  ).toString();\n  const validBefore = BigInt(\n    Math.floor(Date.now() / 1000 + paymentRequirements.maxTimeoutSeconds),\n  ).toString();\n\n  return {\n    x402Version,\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    payload: {\n      signature: undefined,\n      authorization: {\n        from,\n        to: paymentRequirements.payTo as Address,\n        value: paymentRequirements.maxAmountRequired,\n        validAfter: validAfter.toString(),\n        validBefore: validBefore.toString(),\n        nonce,\n      },\n    },\n  };\n}\n\n/**\n * Signs a payment header using the provided client and payment requirements.\n *\n * @param client - The signer wallet instance used to sign the payment header\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @param unsignedPaymentHeader - The unsigned payment payload to be signed\n * @returns A promise that resolves to the signed payment payload\n */\nexport async function signPaymentHeader<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  paymentRequirements: PaymentRequirements,\n  unsignedPaymentHeader: UnsignedPaymentPayload,\n): Promise<PaymentPayload> {\n  const { signature } = await signAuthorization(\n    client,\n    unsignedPaymentHeader.payload.authorization,\n    paymentRequirements,\n  );\n\n  return {\n    ...unsignedPaymentHeader,\n    payload: {\n      ...unsignedPaymentHeader.payload,\n      signature,\n    },\n  };\n}\n\n/**\n * Creates a complete payment payload by preparing and signing a payment header.\n *\n * @param client - The signer wallet instance used to create and sign the payment\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the complete signed payment payload\n */\nexport async function createPayment<transport extends Transport, chain extends Chain>(\n  client: SignerWallet<chain, transport> | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const from = isSignerWallet(client) ? client.account!.address : client.address;\n  const unsignedPaymentHeader = preparePaymentHeader(from, x402Version, paymentRequirements);\n  return signPaymentHeader(client, paymentRequirements, unsignedPaymentHeader);\n}\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer wallet instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to the encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: SignerWallet | LocalAccount,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const payment = await createPayment(client, x402Version, paymentRequirements);\n  return encodePayment(payment);\n}\n","import { encodePayment } from \"../../utils\";\nimport {\n  Address,\n  pipe,\n  createTransactionMessage,\n  setTransactionMessageFeePayer,\n  setTransactionMessageLifetimeUsingBlockhash,\n  appendTransactionMessageInstructions,\n  partiallySignTransactionMessageWithSigners,\n  prependTransactionMessageInstruction,\n  getBase64EncodedWireTransaction,\n  type KeyPairSigner,\n  fetchEncodedAccount,\n  TransactionSigner,\n  Instruction,\n} from \"@solana/kit\";\nimport { PaymentPayload, PaymentRequirements } from \"../../../types/verify\";\nimport {\n  fetchMint,\n  findAssociatedTokenPda,\n  getCreateAssociatedTokenInstruction,\n  getTransferCheckedInstruction,\n  TOKEN_2022_PROGRAM_ADDRESS,\n} from \"@solana-program/token-2022\";\nimport { TOKEN_PROGRAM_ADDRESS } from \"@solana-program/token\";\nimport {\n  estimateComputeUnitLimitFactory,\n  getSetComputeUnitLimitInstruction,\n  setTransactionMessageComputeUnitPrice,\n} from \"@solana-program/compute-budget\";\nimport { getRpcClient } from \"../../../shared/svm/rpc\";\n\n/**\n * Creates and encodes a payment header for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the payment header\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements containing scheme and network information\n * @returns A promise that resolves to a base64 encoded payment header string\n */\nexport async function createPaymentHeader(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<string> {\n  const paymentPayload = await createAndSignPayment(client, x402Version, paymentRequirements);\n  return encodePayment(paymentPayload);\n}\n\n/**\n * Creates and signs a payment for the given client and payment requirements.\n *\n * @param client - The signer instance used to create and sign the payment tx\n * @param x402Version - The version of the X402 protocol to use\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to a payment payload containing a base64 encoded solana token transfer tx\n */\nexport async function createAndSignPayment(\n  client: KeyPairSigner,\n  x402Version: number,\n  paymentRequirements: PaymentRequirements,\n): Promise<PaymentPayload> {\n  const transactionMessage = await createTransferTransactionMessage(client, paymentRequirements);\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n  const base64EncodedWireTransaction = getBase64EncodedWireTransaction(signedTransaction);\n\n  // return payment payload\n  return {\n    scheme: paymentRequirements.scheme,\n    network: paymentRequirements.network,\n    x402Version: x402Version,\n    payload: {\n      transaction: base64EncodedWireTransaction,\n    },\n  } as PaymentPayload;\n}\n\n/**\n * Creates a transfer transaction message for the given client and payment requirements.\n *\n * @param client - The signer instance used to create the transfer transaction message\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to the transaction message with the transfer instruction\n */\nasync function createTransferTransactionMessage(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n) {\n  const rpc = getRpcClient(paymentRequirements.network);\n\n  // create the transfer instruction\n  const transferInstructions = await createAtaAndTransferInstructions(client, paymentRequirements);\n\n  // create tx to simulate\n  const feePayer = paymentRequirements.extra?.feePayer as Address;\n  const txToSimulate = pipe(\n    createTransactionMessage({ version: 0 }),\n    tx => setTransactionMessageComputeUnitPrice(1, tx), // 1 microlamport priority fee\n    tx => setTransactionMessageFeePayer(feePayer, tx),\n    tx => appendTransactionMessageInstructions(transferInstructions, tx),\n  );\n\n  // estimate the compute budget limit (gas limit)\n  const estimateComputeUnitLimit = estimateComputeUnitLimitFactory({ rpc });\n  const estimatedUnits = await estimateComputeUnitLimit(txToSimulate);\n\n  // finalize the transaction message by adding the compute budget limit and blockhash\n  const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n  const tx = pipe(\n    txToSimulate,\n    tx =>\n      prependTransactionMessageInstruction(\n        getSetComputeUnitLimitInstruction({ units: estimatedUnits }),\n        tx,\n      ),\n    tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n  );\n\n  return tx;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will determine which transfer instruction to create\n * based on the program that created the token (token-2022 or token).\n *\n * @param client - The signer instance used to create the transfer instruction\n * @param paymentRequirements - The payment requirements\n * @returns A promise that resolves to the create ATA (if needed) and transfer instruction\n */\nasync function createAtaAndTransferInstructions(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n): Promise<Instruction[]> {\n  const { asset } = paymentRequirements;\n\n  const rpc = getRpcClient(paymentRequirements.network);\n  const tokenMint = await fetchMint(rpc, asset as Address);\n  const tokenProgramAddress = tokenMint.programAddress;\n\n  // validate that the asset was created by a known token program\n  if (\n    tokenProgramAddress.toString() !== TOKEN_PROGRAM_ADDRESS.toString() &&\n    tokenProgramAddress.toString() !== TOKEN_2022_PROGRAM_ADDRESS.toString()\n  ) {\n    throw new Error(\"Asset was not created by a known token program\");\n  }\n\n  const instructions: Instruction[] = [];\n\n  // create the ATA (if needed)\n  const createAtaIx = await createAtaInstructionOrUndefined(\n    paymentRequirements,\n    tokenProgramAddress,\n  );\n  if (createAtaIx) {\n    instructions.push(createAtaIx);\n  }\n\n  // create the transfer instruction\n  const transferIx = await createTransferInstruction(\n    client,\n    paymentRequirements,\n    tokenMint.data.decimals,\n    tokenProgramAddress,\n  );\n  instructions.push(transferIx);\n\n  return instructions;\n}\n\n/**\n * Returns a create ATA instruction for the payTo address if the ATA account does not exist.\n * The create ATA instruction will be paid for by the feePayer in the payment requirements.\n *\n * This function will work for both spl-token and token-2022.\n *\n * Returns undefined if the ATA account already exists.\n *\n * @param paymentRequirements - The payment requirements\n * @param tokenProgramAddress - The address of the token program\n * @returns A promise that resolves to the create ATA instruction or undefined if the ATA account already exists\n * @throws an error if the feePayer is not provided in the payment requirements\n */\nasync function createAtaInstructionOrUndefined(\n  paymentRequirements: PaymentRequirements,\n  tokenProgramAddress: Address,\n): Promise<Instruction | undefined> {\n  const { asset, payTo, extra, network } = paymentRequirements;\n  const feePayer = extra?.feePayer as Address;\n\n  // feePayer is required\n  if (!feePayer) {\n    throw new Error(\n      \"feePayer is required in paymentRequirements.extra in order to set the \" +\n        \"facilitator as the fee payer for the create associated token account instruction\",\n    );\n  }\n\n  // derive the ATA of the payTo address\n  const [destinationATAAddress] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  // check if the ATA exists\n  const rpc = getRpcClient(network);\n  const maybeAccount = await fetchEncodedAccount(rpc, destinationATAAddress);\n\n  // if the ATA does not exist, return an instruction to create it\n  if (!maybeAccount.exists) {\n    return getCreateAssociatedTokenInstruction({\n      payer: paymentRequirements.extra?.feePayer as TransactionSigner<string>,\n      ata: destinationATAAddress,\n      owner: payTo as Address,\n      mint: asset as Address,\n      tokenProgram: tokenProgramAddress,\n    });\n  }\n\n  // if the ATA exists, return undefined\n  return undefined;\n}\n\n/**\n * Creates a transfer instruction for the given client and payment requirements.\n * This function will create a transfer instruction for a token created by either\n * the token program or the token-2022 program.\n *\n * @param client - The signer instance who's tokens will be debited from\n * @param paymentRequirements - The payment requirements\n * @param decimals - The decimals of the token\n * @param tokenProgramAddress - The address of the token program\n * @returns A promise that resolves to the transfer instruction\n */\nasync function createTransferInstruction(\n  client: KeyPairSigner,\n  paymentRequirements: PaymentRequirements,\n  decimals: number,\n  tokenProgramAddress: Address,\n): Promise<Instruction> {\n  const { asset, maxAmountRequired: amount, payTo } = paymentRequirements;\n\n  const [sourceATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: client.address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  const [destinationATA] = await findAssociatedTokenPda({\n    mint: asset as Address,\n    owner: payTo as Address,\n    tokenProgram: tokenProgramAddress,\n  });\n\n  return getTransferCheckedInstruction(\n    {\n      source: sourceATA,\n      mint: asset as Address,\n      destination: destinationATA,\n      authority: client,\n      amount: BigInt(amount),\n      decimals: decimals,\n    },\n    { programAddress: tokenProgramAddress },\n  );\n}\n"],"mappings":"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","names":["createPaymentHeader","tx"]}